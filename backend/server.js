import express from 'express';
import Anthropic from '@anthropic-ai/sdk';
import OpenAI from 'openai';
import cors from 'cors';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(cors());
app.use(express.json({ limit: '50mb' })); // Increase payload limit for large market data

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Load event embeddings (will be generated by Python script)
let eventEmbeddings = [];
const embeddingsPath = path.join(__dirname, 'data', 'event_embeddings.json');

// Try to load embeddings if they exist
if (fs.existsSync(embeddingsPath)) {
  try {
    const embeddingsData = fs.readFileSync(embeddingsPath, 'utf-8');
    eventEmbeddings = JSON.parse(embeddingsData);
    console.log(`Loaded ${eventEmbeddings.length} event embeddings`);
  } catch (err) {
    console.warn('Could not load event embeddings:', err.message);
  }
} else {
  console.warn('Event embeddings not found. Run: npm run update-data');
}

// Cosine similarity function
function cosineSimilarity(a, b) {
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

// Semantic search endpoint
app.post('/api/semantic-search', async (req, res) => {
  const { query, topK = 150 } = req.body;

  if (!query) {
    return res.status(400).json({ error: 'Missing query' });
  }

  try {
    // Generate embedding for the query
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: query,
    });

    const queryEmbedding = response.data[0].embedding;

    // Calculate similarity scores for all events
    const scores = eventEmbeddings.map(event => ({
      title: event.title,
      platform: event.platform,
      event_ticker: event.event_ticker,
      similarity: cosineSimilarity(queryEmbedding, event.embedding)
    }));

    // Sort by similarity and return top K
    scores.sort((a, b) => b.similarity - a.similarity);
    const topResults = scores.slice(0, topK).map(({ title, platform, event_ticker }) => ({
      title,
      platform,
      event_ticker
    }));

    return res.status(200).json({ results: topResults });

  } catch (error) {
    console.error('Semantic search error:', error);
    return res.status(500).json({ error: 'Semantic search failed' });
  }
});

app.post('/api/suggestions', async (req, res) => {
  const { query, events } = req.body;

  if (!query || !events) {
    return res.status(400).json({ error: 'Missing query or events' });
  }

  try {
    // Create a concise prompt for Claude
    const prompt = `You are helping users discover prediction markets on Kalshi. Given a search query, suggest relevant search terms and categories.

User's search query: "${query}"

Available market categories and examples:
${events.slice(0, 30).map(e => `- ${e.title}`).join('\n')}

Task: Generate 3-6 smart search suggestions that will help the user find relevant markets. Consider:
1. Semantic understanding (e.g., "crypto" should suggest Bitcoin, Ethereum)
2. Related topics and synonyms
3. Popular market categories
4. Trending events

Return ONLY a JSON array of suggestions in this format:
[
  {"type": "category", "text": "Crypto markets", "query": "Bitcoin"},
  {"type": "event", "text": "Bitcoin price predictions", "query": "Bitcoin"}
]

Types: "category" for broad topics, "event" for specific markets.`;

    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 500,
      messages: [{
        role: 'user',
        content: prompt
      }]
    });

    // Extract JSON from Claude's response
    const responseText = message.content[0].text;
    const jsonMatch = responseText.match(/\[[\s\S]*\]/);

    if (jsonMatch) {
      const suggestions = JSON.parse(jsonMatch[0]);
      return res.status(200).json({ suggestions });
    } else {
      // Fallback if Claude doesn't return valid JSON
      return res.status(200).json({
        suggestions: [
          { type: 'event', text: `Search for "${query}"`, query: query }
        ]
      });
    }

  } catch (error) {
    console.error('Claude API error:', error);
    return res.status(500).json({
      error: 'AI suggestion failed',
      suggestions: [
        { type: 'event', text: `Search for "${query}"`, query: query }
      ]
    });
  }
});

// New endpoint for AI chat and event recommendations
app.post('/api/chat', async (req, res) => {
  const { message, chatHistory, rankedEvents, allEventTitles, userPreferences } = req.body;

  console.log('Received chat request:', {
    message,
    rankedEventsCount: rankedEvents?.length,
    totalEventTitles: allEventTitles?.length
  });

  console.log('Sample event titles (first 10):', allEventTitles?.slice(0, 10));

  if (!message) {
    console.error('Missing required fields:', { hasMessage: !!message });
    return res.status(400).json({ error: 'Missing message' });
  }

  try {
    // Build context about user preferences
    const preferenceContext = userPreferences ? `
User's past interactions:
- Liked events: ${userPreferences.liked.length} events
- Dismissed events: ${userPreferences.dismissed.length} events
- Clicked events: ${userPreferences.clicked.length} events

Events the user has shown interest in (liked/clicked):
${Array.from(new Set([...userPreferences.liked, ...userPreferences.clicked]))
  .slice(0, 10)
  .map(ticker => {
    const event = rankedEvents?.find(e => e.event_ticker === ticker);
    return event ? `- ${event.title} (${event.platform})` : null;
  })
  .filter(Boolean)
  .join('\n')}

Events the user dismissed (avoid similar topics):
${userPreferences.dismissed
  .slice(0, 5)
  .map(ticker => {
    const event = rankedEvents?.find(e => e.event_ticker === ticker);
    return event ? `- ${event.title}` : null;
  })
  .filter(Boolean)
  .join('\n')}
` : '';

    // Create condensed event list for Claude - limit to top 200 to control token usage
    const limitedEventTitles = allEventTitles ? allEventTitles.slice(0, 200) : [];
    const allEventsContext = limitedEventTitles.length > 0
      ? `\n\nSEARCH RESULTS (${limitedEventTitles.length} events matching your query):\n${limitedEventTitles.map(e => {
          // Shorten title to first 50 chars to save tokens
          const shortTitle = e.title.length > 50 ? e.title.substring(0, 50) + '...' : e.title;
          return `${e.event_ticker}: [${e.platform}] ${shortTitle}`;
        }).join('\n')}`
      : '';

    const rankedEventsContext = rankedEvents && rankedEvents.length > 0
      ? `\n\nTOP RANKED EVENTS (highest quality markets from search results):\n${rankedEvents.slice(0, 20).map(e =>
          `${e.event_ticker}: ${e.title.substring(0, 60)}${e.title.length > 60 ? '...' : ''} [${e.platform}] Score: ${e.metrics.compositeScore.toFixed(0)}`
        ).join('\n')}`
      : '';

    // Create comprehensive prompt for Claude
    const systemPrompt = `You are a helpful AI assistant for a prediction market platform. You help users discover interesting events on Kalshi and Polymarket based on their interests.

${preferenceContext}${allEventsContext}${rankedEventsContext}

**ABOUT THE RANKING:**
Events are ranked by a composite quality score (0-100) that considers:
- Liquidity (35%): Can you execute trades?
- Volume Velocity (25%): Is it actively trading right now?
- Total Volume (20%): Historical interest
- Spread Quality (10%): Execution costs
- Market Count (10%): Breadth of betting options

Your tasks:
1. **SCAN THE SEARCH RESULTS** to find the most relevant events for the user's query
2. Prioritize events from the TOP RANKED section (these have the best quality scores)
3. Have a natural conversation explaining why these events match their interests
4. Recommend 3-5 events that best match what they're looking for
5. Include ALL events you mention in your RECOMMENDATIONS JSON
6. Learn from their preferences - avoid topics they've dismissed
7. Format your response with clear paragraphs and bullet points for readability

IMPORTANT:
- The search results are already filtered to be relevant to the user's query
- TOP RANKED section shows the highest quality markets (Score 70+ is excellent)
- Balance between relevance and quality - don't recommend low-quality markets just because they match
- You can only recommend events that appear in the search results above

IMPORTANT FORMATTING:
- Keep paragraphs short (2-3 sentences max)
- Use proper markdown bullet points (- or *) with blank lines before and after lists
- Add blank lines between sections and paragraphs
- Use **bold** for emphasis on key terms
- Be concise and scannable

Example of good formatting:
Here's what I found for you.

**Top Markets:**
- Market A - reason why
- Market B - reason why

Let me explain each one.

CRITICAL REQUIREMENT - RECOMMENDATIONS JSON:
You MUST include ALL events you mention by name or describe in your conversational response in the RECOMMENDATIONS JSON at the end.

If you mention 5 events in your response, you MUST include all 5 in the JSON.
If you mention 10 events, you MUST include all 10 in the JSON.
EVERY single event you reference must appear in the recommendations list.

The frontend will handle sorting and ranking - your job is to identify ALL relevant events and include them ALL.

When recommending events, return them in this EXACT JSON format at the end of your response:
RECOMMENDATIONS:
[
  {
    "eventTicker": "EVENT-TICKER-1",
    "reason": "Brief explanation of why this matches their interest"
  },
  {
    "eventTicker": "EVENT-TICKER-2",
    "reason": "Brief explanation of why this matches their interest"
  }
  ... (continue for EVERY event you mentioned above)
]

CRITICAL: The eventTicker field MUST be the EXACT ticker string from the event lists above.
- DO NOT create your own ticker format or abbreviations
- COPY the exact ticker string before the colon (e.g., "KXPHILIPPINESPRES-28" NOT "KXPHILPRES")
- Example: If you see "KXPHILIPPINESPRES-28: [kalshi] Philippine presidential...", use "KXPHILIPPINESPRES-28"
- The ticker is always the part BEFORE the colon in the event listings

Count the events you mentioned in your response and verify you have the same number in the RECOMMENDATIONS JSON.`;

    // Build conversation history for Claude
    const messages = chatHistory.map(msg => ({
      role: msg.role,
      content: msg.content
    }));

    // Estimate token count for debugging (rough: 1 token â‰ˆ 4 chars)
    const estimatedTokens = Math.ceil(systemPrompt.length / 4);
    console.log(`Sending request to Claude... (estimated ~${estimatedTokens} tokens in system prompt)`);

    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 3000,
      system: systemPrompt,
      messages: messages
    });

    console.log('Received response from Claude');
    const responseText = response.content[0].text;

    // Extract recommendations if present - use greedy match to capture all JSON
    let recommendedMarkets = [];
    let cleanedResponse = responseText;

    // Try to extract recommendations with improved regex (greedy match from RECOMMENDATIONS to end)
    const recommendationsMatch = responseText.match(/RECOMMENDATIONS:\s*(\[[\s\S]*\])/);

    if (recommendationsMatch) {
      try {
        // Get the JSON string and find the matching closing bracket
        const jsonStart = recommendationsMatch.index + recommendationsMatch[0].indexOf('[');
        let bracketCount = 0;
        let jsonEnd = jsonStart;

        // Manually parse to find the complete JSON array
        for (let i = jsonStart; i < responseText.length; i++) {
          if (responseText[i] === '[') bracketCount++;
          if (responseText[i] === ']') {
            bracketCount--;
            if (bracketCount === 0) {
              jsonEnd = i + 1;
              break;
            }
          }
        }

        const jsonString = responseText.substring(jsonStart, jsonEnd);
        recommendedMarkets = JSON.parse(jsonString);

        console.log(`Successfully extracted ${recommendedMarkets.length} recommendations:`);
        recommendedMarkets.forEach((rec, i) => {
          console.log(`  ${i + 1}. ${rec.eventTicker}: ${rec.reason?.substring(0, 50)}...`);
        });

        // Remove the recommendations section from the response text
        cleanedResponse = responseText.substring(0, recommendationsMatch.index).trim();

        return res.status(200).json({
          response: cleanedResponse,
          recommendedMarkets
        });
      } catch (e) {
        console.error('Failed to parse recommendations:', e);
        console.error('Attempted to parse:', recommendationsMatch[1]?.substring(0, 200));
      }
    }

    console.log('No recommendations found in response');
    return res.status(200).json({
      response: responseText,
      recommendedMarkets
    });

  } catch (error) {
    console.error('Claude chat error:', error);
    console.error('Error details:', error.message, error.stack);
    return res.status(500).json({
      error: 'Chat failed',
      response: 'Sorry, I encountered an error. Please try again.',
      details: error.message
    });
  }
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`API server running on http://localhost:${PORT}`);
});
